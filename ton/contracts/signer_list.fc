;; XRPL Signer List for TON
;; Weighted multisig with proposal-based governance

#include "stdlib.fc";

;; Error codes
const int err::not_authorized = 100;
const int err::invalid_quorum = 101;
const int err::invalid_weight = 102;
const int err::signer_exists = 103;
const int err::signer_not_found = 104;
const int err::not_active = 105;
const int err::not_signer = 106;
const int err::already_approved = 107;
const int err::quorum_not_met = 108;
const int err::proposal_not_pending = 109;

;; Status
const int status::pending = 0;
const int status::executed = 1;
const int status::rejected = 2;

;; Storage
global cell signer_lists;  ;; list_id => (owner, signers dict, quorum, active, created_at)
global cell proposals;  ;; proposal_id => (list_id, proposer, description, approvals dict, approval_weight, status, created_at)
global int next_list_id;
global int next_proposal_id;

() load_data() impure {
    var ds = get_data().begin_parse();
    signer_lists = ds~load_dict();
    proposals = ds~load_dict();
    next_list_id = ds~load_uint(64);
    next_proposal_id = ds~load_uint(64);
}

() save_data() impure {
    set_data(begin_cell()
        .store_dict(signer_lists)
        .store_dict(proposals)
        .store_uint(next_list_id, 64)
        .store_uint(next_proposal_id, 64)
    .end_cell());
}

;; Create signer list
int create_signer_list(slice owner, int quorum) impure {
    throw_unless(err::invalid_quorum, (quorum > 0) & (quorum <= 10000));

    int list_id = next_list_id;
    next_list_id += 1;

    cell signer_list = begin_cell()
        .store_slice(owner)
        .store_dict(new_dict())
        .store_uint(quorum, 16)
        .store_int(-1, 1)  ;; active
        .store_uint(now(), 64)
    .end_cell();

    signer_lists~udict_set_ref(64, list_id, signer_list);
    save_data();

    return list_id;
}

;; Add signer
() add_signer(slice owner, int list_id, slice new_signer, int weight) impure {
    throw_unless(err::invalid_weight, (weight > 0) & (weight <= 10000));

    (cell value, int found) = signer_lists.udict_get_ref?(64, list_id);
    throw_unless(err::signer_not_found, found);

    var ds = value.begin_parse();
    slice list_owner = ds~load_msg_addr();
    cell signers = ds~load_dict();
    int quorum = ds~load_uint(16);
    int active = ds~load_int(1);
    int created_at = ds~load_uint(64);

    throw_unless(err::not_authorized, equal_slices(owner, list_owner));
    throw_unless(err::not_active, active);

    int signer_hash = slice_hash(new_signer);
    (slice val, int sig_found) = signers.udict_get?(256, signer_hash);
    throw_if(err::signer_exists, sig_found);

    signers~udict_set_builder(256, signer_hash, begin_cell().store_uint(weight, 16));

    cell updated = begin_cell()
        .store_slice(list_owner)
        .store_dict(signers)
        .store_uint(quorum, 16)
        .store_int(active, 1)
        .store_uint(created_at, 64)
    .end_cell();

    signer_lists~udict_set_ref(64, list_id, updated);
    save_data();
}

;; Create proposal
int create_proposal(slice proposer, int list_id) impure {
    (cell value, int found) = signer_lists.udict_get_ref?(64, list_id);
    throw_unless(err::not_active, found);

    var ds = value.begin_parse();
    slice list_owner = ds~load_msg_addr();
    cell signers = ds~load_dict();
    int quorum = ds~load_uint(16);
    int active = ds~load_int(1);

    throw_unless(err::not_active, active);

    int proposer_hash = slice_hash(proposer);
    (slice val, int is_signer) = signers.udict_get?(256, proposer_hash);
    throw_unless(err::not_signer, is_signer);

    int proposal_id = next_proposal_id;
    next_proposal_id += 1;

    cell proposal = begin_cell()
        .store_uint(list_id, 64)
        .store_slice(proposer)
        .store_dict(new_dict())  ;; approvals
        .store_uint(0, 32)  ;; approval_weight
        .store_uint(status::pending, 8)
        .store_uint(now(), 64)
    .end_cell();

    proposals~udict_set_ref(64, proposal_id, proposal);
    save_data();

    return proposal_id;
}

;; Approve proposal
() approve_proposal(slice approver, int list_id, int proposal_id) impure {
    (cell value, int found) = proposals.udict_get_ref?(64, proposal_id);
    throw_unless(err::proposal_not_pending, found);

    var ds = value.begin_parse();
    int prop_list_id = ds~load_uint(64);
    slice proposer = ds~load_msg_addr();
    cell approvals = ds~load_dict();
    int approval_weight = ds~load_uint(32);
    int prop_status = ds~load_uint(8);
    int created_at = ds~load_uint(64);

    throw_unless(err::proposal_not_pending, prop_status == status::pending);

    ;; Get signer list
    (cell list_value, int list_found) = signer_lists.udict_get_ref?(64, list_id);
    throw_unless(err::not_active, list_found);

    var list_ds = list_value.begin_parse();
    list_ds~load_msg_addr();
    cell signers = list_ds~load_dict();

    ;; Check if approver is a signer
    int approver_hash = slice_hash(approver);
    (slice weight_val, int is_signer) = signers.udict_get?(256, approver_hash);
    throw_unless(err::not_signer, is_signer);

    ;; Check not already approved
    (slice app_val, int already_approved) = approvals.udict_get?(256, approver_hash);
    throw_if(err::already_approved, already_approved);

    int weight = weight_val~load_uint(16);
    approval_weight += weight;

    approvals~udict_set_builder(256, approver_hash, begin_cell().store_int(-1, 1));

    cell updated = begin_cell()
        .store_uint(prop_list_id, 64)
        .store_slice(proposer)
        .store_dict(approvals)
        .store_uint(approval_weight, 32)
        .store_uint(prop_status, 8)
        .store_uint(created_at, 64)
    .end_cell();

    proposals~udict_set_ref(64, proposal_id, updated);
    save_data();
}

;; Execute proposal
() execute_proposal(slice executor, int list_id, int proposal_id) impure {
    (cell value, int found) = proposals.udict_get_ref?(64, proposal_id);
    throw_unless(err::proposal_not_pending, found);

    var ds = value.begin_parse();
    int prop_list_id = ds~load_uint(64);
    slice proposer = ds~load_msg_addr();
    cell approvals = ds~load_dict();
    int approval_weight = ds~load_uint(32);
    int prop_status = ds~load_uint(8);
    int created_at = ds~load_uint(64);

    throw_unless(err::proposal_not_pending, prop_status == status::pending);

    ;; Get signer list
    (cell list_value, int list_found) = signer_lists.udict_get_ref?(64, list_id);
    throw_unless(err::not_active, list_found);

    var list_ds = list_value.begin_parse();
    list_ds~load_msg_addr();
    cell signers = list_ds~load_dict();
    int quorum = list_ds~load_uint(16);
    int active = list_ds~load_int(1);

    throw_unless(err::not_active, active);

    ;; Check executor is a signer
    int executor_hash = slice_hash(executor);
    (slice val, int is_signer) = signers.udict_get?(256, executor_hash);
    throw_unless(err::not_signer, is_signer);

    throw_unless(err::quorum_not_met, approval_weight >= quorum);

    cell updated = begin_cell()
        .store_uint(prop_list_id, 64)
        .store_slice(proposer)
        .store_dict(approvals)
        .store_uint(approval_weight, 32)
        .store_uint(status::executed, 8)
        .store_uint(created_at, 64)
    .end_cell();

    proposals~udict_set_ref(64, proposal_id, updated);
    save_data();
}

;; Receive internal message
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    load_data();

    int op = in_msg_body~load_uint(32);
    slice sender = in_msg_full.begin_parse().skip_bits(4).load_msg_addr();

    if (op == 1) { ;; create_signer_list
        int quorum = in_msg_body~load_uint(16);
        create_signer_list(sender, quorum);
    }

    if (op == 2) { ;; add_signer
        int list_id = in_msg_body~load_uint(64);
        slice new_signer = in_msg_body~load_msg_addr();
        int weight = in_msg_body~load_uint(16);
        add_signer(sender, list_id, new_signer, weight);
    }

    if (op == 3) { ;; create_proposal
        int list_id = in_msg_body~load_uint(64);
        create_proposal(sender, list_id);
    }

    if (op == 4) { ;; approve_proposal
        int list_id = in_msg_body~load_uint(64);
        int proposal_id = in_msg_body~load_uint(64);
        approve_proposal(sender, list_id, proposal_id);
    }

    if (op == 5) { ;; execute_proposal
        int list_id = in_msg_body~load_uint(64);
        int proposal_id = in_msg_body~load_uint(64);
        execute_proposal(sender, list_id, proposal_id);
    }
}
