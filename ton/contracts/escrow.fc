;; XRPL Escrow for TON
;; Time-locked and hash-locked conditional payments (HTLC)

#include "stdlib.fc";

;; Storage schema
;; escrows: dict(int id => (slice sender, slice receiver, int amount, int release_time, int cancel_time, int condition_hash, int status))

;; Error codes
const int err::not_authorized = 100;
const int err::not_released = 101;
const int err::wrong_preimage = 102;
const int err::invalid_amount = 103;
const int err::too_early = 104;
const int err::already_executed = 105;

;; Status
const int status::active = 0;
const int status::executed = 1;
const int status::cancelled = 2;

;; Storage
global cell escrows;
global int next_id;

() load_data() impure {
    var ds = get_data().begin_parse();
    escrows = ds~load_dict();
    next_id = ds~load_uint(64);
}

() save_data() impure {
    set_data(begin_cell()
        .store_dict(escrows)
        .store_uint(next_id, 64)
    .end_cell());
}

;; Create time-locked escrow
int create_time_locked(slice sender, slice receiver, int amount, int release_time, int cancel_time) impure {
    throw_unless(err::invalid_amount, amount > 0);

    int escrow_id = next_id;
    next_id += 1;

    cell escrow = begin_cell()
        .store_slice(sender)
        .store_slice(receiver)
        .store_coins(amount)
        .store_uint(release_time, 64)
        .store_uint(cancel_time, 64)
        .store_uint(0, 256)  ;; no condition hash
        .store_uint(status::active, 8)
    .end_cell();

    escrows~udict_set_ref(64, escrow_id, escrow);
    save_data();

    return escrow_id;
}

;; Create hash-locked escrow (HTLC)
int create_hash_locked(slice sender, slice receiver, int amount, int release_time, int cancel_time, int condition_hash) impure {
    throw_unless(err::invalid_amount, amount > 0);

    int escrow_id = next_id;
    next_id += 1;

    cell escrow = begin_cell()
        .store_slice(sender)
        .store_slice(receiver)
        .store_coins(amount)
        .store_uint(release_time, 64)
        .store_uint(cancel_time, 64)
        .store_uint(condition_hash, 256)
        .store_uint(status::active, 8)
    .end_cell();

    escrows~udict_set_ref(64, escrow_id, escrow);
    save_data();

    return escrow_id;
}

;; Execute escrow
() execute_escrow(slice receiver, int escrow_id, int preimage) impure {
    (cell value, int found) = escrows.udict_get_ref?(64, escrow_id);
    throw_unless(err::already_executed, found);

    var ds = value.begin_parse();
    slice esc_sender = ds~load_msg_addr();
    slice esc_receiver = ds~load_msg_addr();
    int amount = ds~load_coins();
    int release_time = ds~load_uint(64);
    int cancel_time = ds~load_uint(64);
    int condition_hash = ds~load_uint(256);
    int esc_status = ds~load_uint(8);

    throw_unless(err::not_authorized, equal_slices(receiver, esc_receiver));
    throw_unless(err::already_executed, esc_status == status::active);
    throw_unless(err::too_early, now() >= release_time);

    ;; Verify hash condition if present
    if (condition_hash != 0) {
        int computed_hash = slice_hash(begin_cell().store_uint(preimage, 256).end_cell().begin_parse());
        throw_unless(err::wrong_preimage, computed_hash == condition_hash);
    }

    cell updated = begin_cell()
        .store_slice(esc_sender)
        .store_slice(esc_receiver)
        .store_coins(amount)
        .store_uint(release_time, 64)
        .store_uint(cancel_time, 64)
        .store_uint(condition_hash, 256)
        .store_uint(status::executed, 8)
    .end_cell();

    escrows~udict_set_ref(64, escrow_id, updated);
    save_data();

    ;; Send funds to receiver
    send_raw_message(begin_cell()
        .store_uint(0x10, 6)
        .store_slice(esc_receiver)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .end_cell(), 1);
}

;; Cancel escrow
() cancel_escrow(slice sender, int escrow_id) impure {
    (cell value, int found) = escrows.udict_get_ref?(64, escrow_id);
    throw_unless(err::already_executed, found);

    var ds = value.begin_parse();
    slice esc_sender = ds~load_msg_addr();
    slice esc_receiver = ds~load_msg_addr();
    int amount = ds~load_coins();
    int release_time = ds~load_uint(64);
    int cancel_time = ds~load_uint(64);
    int condition_hash = ds~load_uint(256);
    int esc_status = ds~load_uint(8);

    throw_unless(err::not_authorized, equal_slices(sender, esc_sender));
    throw_unless(err::already_executed, esc_status == status::active);
    throw_unless(err::too_early, now() >= cancel_time);

    cell updated = begin_cell()
        .store_slice(esc_sender)
        .store_slice(esc_receiver)
        .store_coins(amount)
        .store_uint(release_time, 64)
        .store_uint(cancel_time, 64)
        .store_uint(condition_hash, 256)
        .store_uint(status::cancelled, 8)
    .end_cell();

    escrows~udict_set_ref(64, escrow_id, updated);
    save_data();

    ;; Refund to sender
    send_raw_message(begin_cell()
        .store_uint(0x10, 6)
        .store_slice(esc_sender)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .end_cell(), 1);
}

;; Get methods
int is_executable(int escrow_id) method_id {
    load_data();
    (cell value, int found) = escrows.udict_get_ref?(64, escrow_id);
    if (found) {
        var ds = value.begin_parse();
        ds~skip_bits(256 + 256 + 124);
        int release_time = ds~load_uint(64);
        ds~skip_bits(64 + 256);
        int esc_status = ds~load_uint(8);
        return (esc_status == status::active) & (now() >= release_time);
    }
    return 0;
}

;; Receive internal message
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    load_data();

    int op = in_msg_body~load_uint(32);
    slice sender = in_msg_full.begin_parse().skip_bits(4).load_msg_addr();

    if (op == 1) { ;; create_time_locked
        slice receiver = in_msg_body~load_msg_addr();
        int release_time = in_msg_body~load_uint(64);
        int cancel_time = in_msg_body~load_uint(64);
        create_time_locked(sender, receiver, msg_value, release_time, cancel_time);
    }

    if (op == 2) { ;; create_hash_locked
        slice receiver = in_msg_body~load_msg_addr();
        int release_time = in_msg_body~load_uint(64);
        int cancel_time = in_msg_body~load_uint(64);
        int condition_hash = in_msg_body~load_uint(256);
        create_hash_locked(sender, receiver, msg_value, release_time, cancel_time, condition_hash);
    }

    if (op == 3) { ;; execute_escrow
        int escrow_id = in_msg_body~load_uint(64);
        int preimage = in_msg_body~load_uint(256);
        execute_escrow(sender, escrow_id, preimage);
    }

    if (op == 4) { ;; cancel_escrow
        int escrow_id = in_msg_body~load_uint(64);
        cancel_escrow(sender, escrow_id);
    }
}
