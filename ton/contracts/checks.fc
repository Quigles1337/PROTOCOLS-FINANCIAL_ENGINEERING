;; XRPL Checks for TON
;; Deferred payments with partial cashing support

#include "stdlib.fc";

;; Error codes
const int err::not_authorized = 100;
const int err::check_expired = 101;
const int err::invalid_amount = 102;
const int err::check_not_active = 103;
const int err::insufficient_remaining = 104;

;; Status
const int status::active = 0;
const int status::cashed = 1;
const int status::cancelled = 2;

;; Storage
global cell checks;
global int next_id;

() load_data() impure {
    var ds = get_data().begin_parse();
    checks = ds~load_dict();
    next_id = ds~load_uint(64);
}

() save_data() impure {
    set_data(begin_cell()
        .store_dict(checks)
        .store_uint(next_id, 64)
    .end_cell());
}

;; Create check
int create_check(slice sender, slice receiver, int amount, int expiration) impure {
    throw_unless(err::invalid_amount, amount > 0);

    int check_id = next_id;
    next_id += 1;

    cell check = begin_cell()
        .store_slice(sender)
        .store_slice(receiver)
        .store_coins(amount)
        .store_coins(0)  ;; cashed_amount
        .store_uint(expiration, 64)
        .store_uint(status::active, 8)
        .store_uint(now(), 64)
    .end_cell();

    checks~udict_set_ref(64, check_id, check);
    save_data();

    return check_id;
}

;; Cash check
() cash_check(slice receiver, int check_id, int amount) impure {
    (cell value, int found) = checks.udict_get_ref?(64, check_id);
    throw_unless(err::check_not_active, found);

    var ds = value.begin_parse();
    slice ch_sender = ds~load_msg_addr();
    slice ch_receiver = ds~load_msg_addr();
    int total_amount = ds~load_coins();
    int cashed_amount = ds~load_coins();
    int expiration = ds~load_uint(64);
    int ch_status = ds~load_uint(8);
    int created_at = ds~load_uint(64);

    throw_unless(err::not_authorized, equal_slices(receiver, ch_receiver));
    throw_unless(err::check_not_active, ch_status == status::active);
    throw_unless(err::check_expired, now() < expiration);

    int remaining = total_amount - cashed_amount;
    throw_unless(err::insufficient_remaining, (amount > 0) & (amount <= remaining));

    cashed_amount += amount;
    int new_status = ch_status;
    if (cashed_amount == total_amount) {
        new_status = status::cashed;
    }

    cell updated = begin_cell()
        .store_slice(ch_sender)
        .store_slice(ch_receiver)
        .store_coins(total_amount)
        .store_coins(cashed_amount)
        .store_uint(expiration, 64)
        .store_uint(new_status, 8)
        .store_uint(created_at, 64)
    .end_cell();

    checks~udict_set_ref(64, check_id, updated);
    save_data();

    ;; Send funds to receiver
    send_raw_message(begin_cell()
        .store_uint(0x10, 6)
        .store_slice(ch_receiver)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .end_cell(), 1);
}

;; Cancel check
() cancel_check(slice sender, int check_id) impure {
    (cell value, int found) = checks.udict_get_ref?(64, check_id);
    throw_unless(err::check_not_active, found);

    var ds = value.begin_parse();
    slice ch_sender = ds~load_msg_addr();
    slice ch_receiver = ds~load_msg_addr();
    int total_amount = ds~load_coins();
    int cashed_amount = ds~load_coins();
    int expiration = ds~load_uint(64);
    int ch_status = ds~load_uint(8);
    int created_at = ds~load_uint(64);

    throw_unless(err::not_authorized, equal_slices(sender, ch_sender));
    throw_unless(err::check_not_active, ch_status == status::active);

    int remaining = total_amount - cashed_amount;

    cell updated = begin_cell()
        .store_slice(ch_sender)
        .store_slice(ch_receiver)
        .store_coins(total_amount)
        .store_coins(cashed_amount)
        .store_uint(expiration, 64)
        .store_uint(status::cancelled, 8)
        .store_uint(created_at, 64)
    .end_cell();

    checks~udict_set_ref(64, check_id, updated);
    save_data();

    ;; Refund remaining to sender
    if (remaining > 0) {
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(ch_sender)
            .store_coins(remaining)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell(), 1);
    }
}

;; Get methods
int get_remaining_amount(int check_id) method_id {
    load_data();
    (cell value, int found) = checks.udict_get_ref?(64, check_id);
    if (found) {
        var ds = value.begin_parse();
        ds~skip_bits(256 + 256);
        int total_amount = ds~load_coins();
        int cashed_amount = ds~load_coins();
        return total_amount - cashed_amount;
    }
    return 0;
}

;; Receive internal message
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    load_data();

    int op = in_msg_body~load_uint(32);
    slice sender = in_msg_full.begin_parse().skip_bits(4).load_msg_addr();

    if (op == 1) { ;; create_check
        slice receiver = in_msg_body~load_msg_addr();
        int expiration = in_msg_body~load_uint(64);
        create_check(sender, receiver, msg_value, expiration);
    }

    if (op == 2) { ;; cash_check
        int check_id = in_msg_body~load_uint(64);
        int amount = in_msg_body~load_coins();
        cash_check(sender, check_id, amount);
    }

    if (op == 3) { ;; cancel_check
        int check_id = in_msg_body~load_uint(64);
        cancel_check(sender, check_id);
    }
}
